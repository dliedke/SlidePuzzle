<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸ§© Quebra-CabeÃ§a ðŸ§©</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      background: linear-gradient(135deg, #2c3e50 0%, #4ca1af 100%);
      min-height: 100vh;
      color: #fff;
    }
    #title {
      font-size: 2rem;
      margin: 0.5rem 0;
      color: #ecf0f1;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    #controls {
      margin-bottom: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .size-btn, #new-btn, #toggle-hints, #dialog-new-btn {
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      background: #3498db;
      color: #fff;
    }
    .size-btn:hover, #new-btn:hover, #toggle-hints:hover, #dialog-new-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    #puzzle-container {
      position: relative;
      background: linear-gradient(135deg, #1f2833, #3a4750);
      padding: 8px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      margin-bottom: 1.5rem;
    }
    .tile {
      position: absolute;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      font-weight: bold;
      color: #fff;
      user-select: none;
      background: linear-gradient(135deg, #4A90E2 0%, #357ABD 100%);
      transition: transform 0.1s, background 0.3s, left 0.3s ease-out, top 0.3s ease-out;
      cursor: pointer;
    }
    .tile:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    }
    .tile.moving {
      z-index: 5;
      transition: left 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                  top 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    .hidden {
      background: transparent;
      box-shadow: none;
      visibility: hidden;
    }
    .correct {
      background: linear-gradient(135deg, #58D68D 0%, #2ECC71 100%) !important;
    }
    .hint {
      background: linear-gradient(135deg, #f4d03f 0%, #f1c40f 100%) !important;
    }
    #info {
      background: rgba(0,0,0,0.6);
      padding: 0.6rem 1.2rem;
      border-radius: 30px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      font-size: 1rem;
      display: inline-block;
      color: #fff;
    }
    #completion-dialog {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #completion-dialog.hidden { display: none; }
    .dialog-content {
      background: linear-gradient(135deg, #ffffff, #e6e6e6);
      padding: 2rem;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .dialog-content h2 { margin-top: 0; color: #333; }
    .dialog-content p {
      font-size: 1.2rem;
      margin: 0.5rem 0;
      color: #555;
    }
    .dialog-content button { margin-top: 1rem; }
  </style>
</head>
<body>
  <h1 id="title">ðŸ§© Quebra-CabeÃ§a ðŸ§©</h1>
  <div id="controls">
    <button class="size-btn" data-size="3">3 Ã— 3</button>
    <button class="size-btn" data-size="4">4 Ã— 4</button>
    <button id="new-btn">Novo Jogo</button>
    <button id="toggle-hints">Ativar Dicas</button>
  </div>
  <div id="puzzle-container"></div>
  <div id="info">Movimentos: <span id="move-count">0</span> | Tempo: <span id="timer">00:00</span></div>
  <div id="completion-dialog" class="hidden">
    <div class="dialog-content">
      <h2>ParabÃ©ns!</h2>
      <p>Movimentos: <span id="dialog-moves">0</span></p>
      <p>Tempo: <span id="dialog-time">00:00</span></p>
      <button id="dialog-new-btn">Novo Jogo</button>
    </div>
  </div>
  <script>
    (function(){
      // DOM Elements
      const puzzleContainer = document.getElementById('puzzle-container');
      const sizeButtons = document.querySelectorAll('.size-btn');
      const newGameButton = document.getElementById('new-btn');
      const toggleHintsButton = document.getElementById('toggle-hints');
      const moveCountElement = document.getElementById('move-count');
      const timerElement = document.getElementById('timer');
      const completionDialog = document.getElementById('completion-dialog');
      const dialogMovesElement = document.getElementById('dialog-moves');
      const dialogTimeElement = document.getElementById('dialog-time');
      const dialogNewGameButton = document.getElementById('dialog-new-btn');

      // Game State Variables
      let puzzleSize = 3;
      let gameBoard = [];
      let emptyTilePosition = { row: 0, column: 0 };
      let moveCount = 0;
      let gameTimer = null;
      let hintsEnabled = false;
      let tileSize = 0;
      let tileGap = 5;
      let isAnimating = false;

      // Event Listeners
      sizeButtons.forEach(button => {
        button.addEventListener('click', () => {
          const newSize = parseInt(button.dataset.size);
          initializeGame(newSize);
        });
      });

      newGameButton.addEventListener('click', () => initializeGame(puzzleSize));
      
      toggleHintsButton.addEventListener('click', toggleHints);
      
      dialogNewGameButton.addEventListener('click', () => {
        initializeGame(puzzleSize);
        completionDialog.classList.add('hidden');
      });

      // Initialize a new game
      function initializeGame(newSize) {
        puzzleSize = newSize;
        clearInterval(gameTimer);
        gameBoard = [];
        moveCount = 0;
        moveCountElement.textContent = '0';
        timerElement.textContent = '00:00';
        isAnimating = false;
        updateHintsButtonText();
        completionDialog.classList.add('hidden');
        
        createSolvedBoard();
        shuffleBoard();
        startGameTimer();
        renderPuzzle();
      }

      // Create the initial solved board
      function createSolvedBoard() {
        for (let row = 0; row < puzzleSize; row++) {
          gameBoard[row] = [];
          for (let column = 0; column < puzzleSize; column++) {
            gameBoard[row][column] = row * puzzleSize + column + 1;
          }
        }
        // Set the last tile as empty (0)
        gameBoard[puzzleSize - 1][puzzleSize - 1] = 0;
        emptyTilePosition = { row: puzzleSize - 1, column: puzzleSize - 1 };
      }

      // Shuffle the board by making random valid moves
      function shuffleBoard() {
        for (let i = 0; i < 1000; i++) {
          const possibleMoves = getAdjacentPositions(emptyTilePosition.row, emptyTilePosition.column);
          const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
          swapTiles(emptyTilePosition, randomMove);
          emptyTilePosition = { row: randomMove.row, column: randomMove.column };
        }
      }

      // Toggle hints on/off
      function toggleHints() {
        hintsEnabled = !hintsEnabled;
        updateHintsButtonText();
        renderPuzzle();
      }

      // Update the hints button text
      function updateHintsButtonText() {
        toggleHintsButton.textContent = hintsEnabled ? 'Desativar Dicas' : 'Ativar Dicas';
      }

      // Calculate tile sizes based on screen size
      function calculateTileSizes() {
        const containerPadding = 8;
        const maxContainerSize = Math.min(window.innerWidth, window.innerHeight) * 0.8;
        const availableSpace = maxContainerSize - containerPadding * 2;
        tileSize = (availableSpace - tileGap * (puzzleSize - 1)) / puzzleSize;
        
        puzzleContainer.style.width = `${maxContainerSize}px`;
        puzzleContainer.style.height = `${maxContainerSize}px`;
      }

      // Get the pixel position for a tile at given row/column
      function getTilePosition(row, column) {
        return {
          left: tileGap + column * (tileSize + tileGap),
          top: tileGap + row * (tileSize + tileGap)
        };
      }

      // Render the entire puzzle
      function renderPuzzle() {
        calculateTileSizes();
        removeObsoleteTiles();
        
        const hintPosition = hintsEnabled ? findBestHintPosition() : null;

        // Create or update tiles for each position
        for (let row = 0; row < puzzleSize; row++) {
          for (let column = 0; column < puzzleSize; column++) {
            const tileValue = gameBoard[row][column];
            if (tileValue === 0) continue; // Skip empty space

            let tileElement = findExistingTile(row, column);
            
            if (!tileElement) {
              tileElement = createNewTile(row, column, tileValue);
            } else {
              updateExistingTile(tileElement, row, column, tileValue);
            }

            positionTile(tileElement, row, column);
            applyTileStyles(tileElement, row, column, tileValue, hintPosition);
          }
        }
      }

      // Remove tiles that no longer exist on the board
      function removeObsoleteTiles() {
        const currentTiles = puzzleContainer.querySelectorAll('.tile');
        currentTiles.forEach(tile => {
          const row = parseInt(tile.dataset.r);
          const column = parseInt(tile.dataset.c);
          const tileValue = gameBoard[row] && gameBoard[row][column];
          if (!tileValue || tileValue === 0) {
            tile.remove();
          }
        });
      }

      // Find existing tile element for given position
      function findExistingTile(row, column) {
        return puzzleContainer.querySelector(`[data-r="${row}"][data-c="${column}"]`);
      }

      // Create a new tile element
      function createNewTile(row, column, value) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.r = row;
        tile.dataset.c = column;
        tile.textContent = value;
        tile.addEventListener('click', handleTileClick);
        puzzleContainer.appendChild(tile);
        return tile;
      }

      // Update an existing tile element
      function updateExistingTile(tile, row, column, value) {
        tile.dataset.r = row;
        tile.dataset.c = column;
        tile.textContent = value;
      }

      // Position a tile at the correct pixel coordinates
      function positionTile(tile, row, column) {
        const position = getTilePosition(row, column);
        tile.style.left = `${position.left}px`;
        tile.style.top = `${position.top}px`;
        tile.style.width = `${tileSize}px`;
        tile.style.height = `${tileSize}px`;
      }

      // Apply visual styles to a tile (correct position, hints, etc.)
      function applyTileStyles(tile, row, column, value, hintPosition) {
        tile.className = 'tile';
        
        // Check if tile is in correct position
        const correctValue = row * puzzleSize + column + 1;
        if (value === correctValue) {
          tile.classList.add('correct');
        }
        
        // Check if tile should show hint
        if (hintPosition && hintPosition.row === row && hintPosition.column === column) {
          tile.classList.add('hint');
        }
      }

      // Handle tile click events
      function handleTileClick(event) {
        if (isAnimating) return; // Prevent clicks during animation
        
        const clickedRow = parseInt(event.currentTarget.dataset.r);
        const clickedColumn = parseInt(event.currentTarget.dataset.c);
        
        if (isTileAdjacentToEmpty(clickedRow, clickedColumn)) {
          animateTileMove(event.currentTarget, clickedRow, clickedColumn);
        }
      }

      // Check if a tile is adjacent to the empty space
      function isTileAdjacentToEmpty(row, column) {
        const rowDistance = Math.abs(row - emptyTilePosition.row);
        const columnDistance = Math.abs(column - emptyTilePosition.column);
        return rowDistance + columnDistance === 1;
      }

      // Animate a tile moving to the empty space
      function animateTileMove(tileElement, fromRow, fromColumn) {
        isAnimating = true;
        
        // Add animation class
        tileElement.classList.add('moving');
        
        // Calculate target position (where empty space is)
        const targetPosition = getTilePosition(emptyTilePosition.row, emptyTilePosition.column);
        
        // Start the animation
        tileElement.style.left = `${targetPosition.left}px`;
        tileElement.style.top = `${targetPosition.top}px`;
        
        // Wait for animation to complete, then update game state
        setTimeout(() => {
          completeTileMove(tileElement, fromRow, fromColumn);
        }, 300); // Match CSS transition duration
      }

      // Complete the tile move after animation finishes
      function completeTileMove(tileElement, fromRow, fromColumn) {
        // Update game board
        swapTiles(emptyTilePosition, { row: fromRow, column: fromColumn });
        emptyTilePosition = { row: fromRow, column: fromColumn };
        
        // Update move counter
        moveCount++;
        moveCountElement.textContent = moveCount;
        
        // Remove animation class
        tileElement.classList.remove('moving');
        
        // Re-render puzzle
        renderPuzzle();
        
        // Check if puzzle is solved
        if (isPuzzleSolved()) {
          handlePuzzleCompletion();
        }
        
        isAnimating = false;
      }

      // Get all positions adjacent to a given position
      function getAdjacentPositions(row, column) {
        const directions = [
          { row: -1, column: 0 }, // up
          { row: 1, column: 0 },  // down
          { row: 0, column: -1 }, // left
          { row: 0, column: 1 }   // right
        ];
        
        return directions
          .map(direction => ({
            row: row + direction.row,
            column: column + direction.column
          }))
          .filter(position => 
            position.row >= 0 && position.row < puzzleSize &&
            position.column >= 0 && position.column < puzzleSize
          );
      }

      // Swap two tiles on the board
      function swapTiles(position1, position2) {
        const temp = gameBoard[position1.row][position1.column];
        gameBoard[position1.row][position1.column] = gameBoard[position2.row][position2.column];
        gameBoard[position2.row][position2.column] = temp;
      }

      // Check if the puzzle is solved
      function isPuzzleSolved() {
        for (let row = 0; row < puzzleSize; row++) {
          for (let column = 0; column < puzzleSize; column++) {
            const expectedValue = (row * puzzleSize + column + 1) % (puzzleSize * puzzleSize);
            if (gameBoard[row][column] !== expectedValue) {
              return false;
            }
          }
        }
        return true;
      }

      // Handle puzzle completion
      function handlePuzzleCompletion() {
        clearInterval(gameTimer);
        dialogMovesElement.textContent = moveCount;
        dialogTimeElement.textContent = timerElement.textContent;
        completionDialog.classList.remove('hidden');
      }

      // Start the game timer
      function startGameTimer() {
        const startTime = Date.now();
        gameTimer = setInterval(() => {
          const elapsedTime = Date.now() - startTime;
          const minutes = Math.floor(elapsedTime / 60000);
          const seconds = Math.floor((elapsedTime / 1000) % 60);
          timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, 1000);
      }

      // Find the best hint position using AI solver
      function findBestHintPosition() {
        const flatBoard = gameBoard.flat();
        const optimalMove = findOptimalNextMove(flatBoard, puzzleSize);
        return optimalMove || findGreedyHintMove();
      }

      // Find optimal next move using IDA* algorithm
      function findOptimalNextMove(boardArray, size) {
        const calculateManhattanDistance = (array) => {
          return array.reduce((total, value, index) => {
            if (value === 0) return total;
            const currentRow = Math.floor(index / size);
            const currentColumn = index % size;
            const targetRow = Math.floor((value - 1) / size);
            const targetColumn = (value - 1) % size;
            return total + Math.abs(currentRow - targetRow) + Math.abs(currentColumn - targetColumn);
          }, 0);
        };

        const directions = [
          { row: -1, column: 0 }, // up
          { row: 1, column: 0 },  // down
          { row: 0, column: -1 }, // left
          { row: 0, column: 1 }   // right
        ];

        let searchBound = calculateManhattanDistance(boardArray);
        const solutionPath = [];

        function depthFirstSearch(currentState, emptyRow, emptyColumn, depth, previousDirection) {
          const heuristic = calculateManhattanDistance(currentState);
          const totalCost = depth + heuristic;
          
          if (totalCost > searchBound) return totalCost;
          if (heuristic === 0) return 'FOUND';
          
          let minCost = Infinity;
          
          for (let directionIndex = 0; directionIndex < 4; directionIndex++) {
            // Avoid moving back to previous position
            if (previousDirection >= 0 && (previousDirection ^ 1) === directionIndex) continue;
            
            const newRow = emptyRow + directions[directionIndex].row;
            const newColumn = emptyColumn + directions[directionIndex].column;
            
            // Check bounds
            if (newRow < 0 || newRow >= size || newColumn < 0 || newColumn >= size) continue;
            
            // Create new state by swapping
            const emptyIndex = emptyRow * size + emptyColumn;
            const newIndex = newRow * size + newColumn;
            const nextState = currentState.slice();
            [nextState[emptyIndex], nextState[newIndex]] = [nextState[newIndex], nextState[emptyIndex]];
            
            const result = depthFirstSearch(nextState, newRow, newColumn, depth + 1, directionIndex);
            
            if (result === 'FOUND') {
              if (depth === 0) {
                solutionPath.push({ row: newRow, column: newColumn });
              }
              return 'FOUND';
            }
            
            if (typeof result === 'number' && result < minCost) {
              minCost = result;
            }
          }
          
          return minCost;
        }

        // Find empty position
        const emptyIndex = boardArray.indexOf(0);
        const emptyRow = Math.floor(emptyIndex / size);
        const emptyColumn = emptyIndex % size;

        // Iterative deepening search
        while (true) {
          const result = depthFirstSearch(boardArray.slice(), emptyRow, emptyColumn, 0, -1);
          if (result === 'FOUND') break;
          if (result === Infinity) return null;
          searchBound = result;
        }

        return solutionPath[0];
      }

      // Find greedy hint move when optimal solver fails
      function findGreedyHintMove() {
        const flatBoard = gameBoard.flat();
        const calculateManhattanDistance = (array) => {
          return array.reduce((total, value, index) => {
            if (value === 0) return total;
            const currentRow = Math.floor(index / puzzleSize);
            const currentColumn = index % puzzleSize;
            const targetRow = Math.floor((value - 1) / puzzleSize);
            const targetColumn = (value - 1) % puzzleSize;
            return total + Math.abs(currentRow - targetRow) + Math.abs(currentColumn - targetColumn);
          }, 0);
        };

        let bestMove = null;
        let bestHeuristic = Infinity;
        
        const adjacentPositions = getAdjacentPositions(emptyTilePosition.row, emptyTilePosition.column);
        
        adjacentPositions.forEach(position => {
          const testBoard = flatBoard.slice();
          const emptyIndex = emptyTilePosition.row * puzzleSize + emptyTilePosition.column;
          const moveIndex = position.row * puzzleSize + position.column;
          
          // Swap to test this move
          [testBoard[emptyIndex], testBoard[moveIndex]] = [testBoard[moveIndex], testBoard[emptyIndex]];
          
          const heuristic = calculateManhattanDistance(testBoard);
          if (heuristic < bestHeuristic) {
            bestHeuristic = heuristic;
            bestMove = position;
          }
        });

        return bestMove;
      }

      // Handle window resize
      window.addEventListener('resize', renderPuzzle);

      // Initialize the game
      initializeGame(puzzleSize);
    })();
  </script>
</body>
</html>