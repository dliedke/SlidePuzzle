<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸ§© Quebra-CabeÃ§a ðŸ§©</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      background: linear-gradient(135deg, #2c3e50 0%, #4ca1af 100%);
      min-height: 100vh;
      color: #fff;
    }
    #title {
      font-size: 2rem;
      margin: 0.5rem 0;
      color: #ecf0f1;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    #controls {
      margin-bottom: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .size-btn, #new-btn, #toggle-hints, #dialog-new-btn {
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      background: #3498db;
      color: #fff;
    }
    .size-btn:hover, #new-btn:hover, #toggle-hints:hover, #dialog-new-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    #puzzle-container {
      position: relative;
      background: linear-gradient(135deg, #1f2833, #3a4750);
      padding: 8px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      margin-bottom: 1.5rem;
    }
    .tile {
      position: absolute;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      font-weight: bold;
      color: #fff;
      user-select: none;
      background: linear-gradient(135deg, #4A90E2 0%, #357ABD 100%);
      transition: transform 0.1s, background 0.3s, left 0.3s ease-out, top 0.3s ease-out;
      cursor: pointer;
    }
    .tile:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    }
    .tile.moving {
      z-index: 5;
      transition: left 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                  top 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    .hidden {
      background: transparent;
      box-shadow: none;
      visibility: hidden;
    }
    .correct {
      background: linear-gradient(135deg, #58D68D 0%, #2ECC71 100%) !important;
    }
    .hint {
      background: linear-gradient(135deg, #f4d03f 0%, #f1c40f 100%) !important;
    }
    #info {
      background: rgba(0,0,0,0.6);
      padding: 0.6rem 1.2rem;
      border-radius: 30px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      font-size: 1rem;
      display: inline-block;
      color: #fff;
    }
    #completion-dialog {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #completion-dialog.hidden { display: none; }
    .dialog-content {
      background: linear-gradient(135deg, #ffffff, #e6e6e6);
      padding: 2rem;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .dialog-content h2 { margin-top: 0; color: #333; }
    .dialog-content p {
      font-size: 1.2rem;
      margin: 0.5rem 0;
      color: #555;
    }
    .dialog-content button { margin-top: 1rem; }
  </style>
</head>
<body>
  <h1 id="title">ðŸ§© Quebra-CabeÃ§a ðŸ§©</h1>
  <div id="controls">
    <button class="size-btn" data-size="3">3 Ã— 3</button>
    <button class="size-btn" data-size="4">4 Ã— 4</button>
    <button id="new-btn">Novo Jogo</button>
    <button id="toggle-hints">Ativar Dicas</button>
  </div>
  <div id="puzzle-container"></div>
  <div id="info">Movimentos: <span id="move-count">0</span> | Tempo: <span id="timer">00:00</span></div>
  <div id="completion-dialog" class="hidden">
    <div class="dialog-content">
      <h2>ParabÃ©ns!</h2>
      <p>Movimentos: <span id="dialog-moves">0</span></p>
      <p>Tempo: <span id="dialog-time">00:00</span></p>
      <button id="dialog-new-btn">Novo Jogo</button>
    </div>
  </div>
  <script>
    (function(){
      const container = document.getElementById('puzzle-container'),
            sizeButtons = document.querySelectorAll('.size-btn'),
            newBtn = document.getElementById('new-btn'),
            toggleHintsBtn = document.getElementById('toggle-hints'),
            moveCountEl = document.getElementById('move-count'),
            timerEl = document.getElementById('timer'),
            dialog = document.getElementById('completion-dialog'),
            dialogMoves = document.getElementById('dialog-moves'),
            dialogTime = document.getElementById('dialog-time'),
            dialogNew = document.getElementById('dialog-new-btn');
      let size=3, board=[], emptyPos={r:0,c:0}, moveCount=0, timerInterval=null, hintsEnabled=false, cellSize=0, gap=5, isAnimating=false;

      sizeButtons.forEach(btn => btn.addEventListener('click', () => initGame(+btn.dataset.size)));
      newBtn.addEventListener('click', () => initGame(size));
      toggleHintsBtn.addEventListener('click', ()=>{ hintsEnabled=!hintsEnabled; toggleHintsBtn.textContent = hintsEnabled? 'Desativar Dicas':'Ativar Dicas'; render(); });
      dialogNew.addEventListener('click', ()=>{ initGame(size); dialog.classList.add('hidden'); });

      function initGame(newSize){
        size = newSize;
        clearInterval(timerInterval);
        board = [];
        moveCount = 0;
        moveCountEl.textContent = '0';
        timerEl.textContent = '00:00';
        isAnimating = false;
        toggleHintsBtn.textContent = hintsEnabled ? 'Desativar Dicas' : 'Ativar Dicas';
        dialog.classList.add('hidden');
        for(let i=0;i<size;i++){ board[i]=[]; for(let j=0;j<size;j++) board[i][j]=i*size+j+1; }
        board[size-1][size-1]=0;
        emptyPos={r:size-1,c:size-1};
        for(let i=0;i<1000;i++){ const moves=getNeighbors(emptyPos.r,emptyPos.c); const m=moves[Math.floor(Math.random()*moves.length)]; swap(emptyPos,m); emptyPos={r:m.r,c:m.c}; }
        startTimer(); render();
      }

      function calculateSizes() {
        const padding = 8;
        const total = Math.min(window.innerWidth, window.innerHeight) * 0.8;
        const inner = total - padding * 2;
        cellSize = (inner - gap * (size - 1)) / size;
        
        container.style.width = `${total}px`;
        container.style.height = `${total}px`;
      }

      function getPosition(r, c) {
        return {
          left: gap + c * (cellSize + gap),
          top: gap + r * (cellSize + gap)
        };
      }

      function render(){
        calculateSizes();
        
        // Remove tiles that no longer exist
        const currentTiles = container.querySelectorAll('.tile');
        currentTiles.forEach(tile => {
          const r = parseInt(tile.dataset.r);
          const c = parseInt(tile.dataset.c);
          const value = board[r] && board[r][c];
          if (!value || value === 0) {
            tile.remove();
          }
        });

        let hintPos = null;
        if(hintsEnabled){ 
          hintPos = findNextMove(board.flat(), size) || computeGreedyHint(); 
        }

        board.forEach((row, i) => row.forEach((v, j) => {
          if (v === 0) return; // Skip empty space

          let tile = container.querySelector(`[data-r="${i}"][data-c="${j}"]`);
          
          if (!tile) {
            // Create new tile
            tile = document.createElement('div');
            tile.className = 'tile';
            tile.dataset.r = i;
            tile.dataset.c = j;
            tile.textContent = v;
            tile.style.width = `${cellSize}px`;
            tile.style.height = `${cellSize}px`;
            tile.addEventListener('click', onTileClick);
            container.appendChild(tile);
          } else {
            // Update existing tile position if it moved
            tile.dataset.r = i;
            tile.dataset.c = j;
            tile.textContent = v;
          }

          // Position the tile
          const pos = getPosition(i, j);
          tile.style.left = `${pos.left}px`;
          tile.style.top = `${pos.top}px`;
          tile.style.width = `${cellSize}px`;
          tile.style.height = `${cellSize}px`;

          // Apply styling
          tile.className = 'tile';
          if (v === i * size + j + 1) tile.classList.add('correct');
          if (hintPos && hintPos.r === i && hintPos.c === j) tile.classList.add('hint');
        }));
      }

      function onTileClick(e){
        if (isAnimating) return; // Prevent clicks during animation
        
        const r = parseInt(e.currentTarget.dataset.r);
        const c = parseInt(e.currentTarget.dataset.c);
        
        if(Math.abs(r-emptyPos.r)+Math.abs(c-emptyPos.c)===1){
          animateMove(e.currentTarget, r, c, emptyPos.r, emptyPos.c);
        }
      }

      function animateMove(tile, fromR, fromC, toR, toC) {
        isAnimating = true;
        
        // Add moving class for better animation
        tile.classList.add('moving');
        
        // Calculate target position
        const targetPos = getPosition(toR, toC);
        
        // Start animation
        tile.style.left = `${targetPos.left}px`;
        tile.style.top = `${targetPos.top}px`;
        
        // Wait for animation to complete
        setTimeout(() => {
          // Update board state
          swap(emptyPos, {r: fromR, c: fromC});
          emptyPos = {r: fromR, c: fromC};
          
          moveCountEl.textContent = ++moveCount;
          
          // Remove moving class
          tile.classList.remove('moving');
          
          // Re-render to update positions and check for completion
          render();
          
          if(isSolved()){
            clearInterval(timerInterval);
            dialogMoves.textContent = moveCount;
            dialogTime.textContent = timerEl.textContent;
            dialog.classList.remove('hidden');
          }
          
          isAnimating = false;
        }, 300); // Match the CSS transition duration
      }

      function getNeighbors(r,c){ return [{r:-1,c:0},{r:1,c:0},{r:0,c:-1},{r:0,c:1}].map(d=>({r:r+d.r,c:c+d.c})).filter(p=>p.r>=0&&p.r<size&&p.c>=0&&p.c<size); }
      function swap(a,b){ [board[a.r][a.c],board[b.r][b.c]]=[board[b.r][b.c],board[a.r][a.c]]; }
      function isSolved(){ return board.every((row,i)=>row.every((v,j)=>v===((i*size+j+1)%(size*size)))); }
      function startTimer(){ const start=Date.now(); timerInterval=setInterval(()=>{ const d=Date.now()-start; timerEl.textContent=`${String(Math.floor(d/60000)).padStart(2,'0')}:${String(Math.floor((d/1000)%60)).padStart(2,'0')}`; },1000); }

      function findNextMove(arr,n){
        const manh=a=>a.reduce((s,v,i)=>v?s+Math.abs(Math.floor(i/n)-Math.floor((v-1)/n))+Math.abs(i%n-((v-1)%n)):s,0);
        const dirs=[{r:-1,c:0},{r:1,c:0},{r:0,c:-1},{r:0,c:1}];
        let bound=manh(arr),path=[];
        function dfs(st,zr,zc,g,prev){
          const h=manh(st),f=g+h; if(f>bound) return f; if(h===0) return 'FOUND'; let min=Infinity;
          for(let dir=0;dir<4;dir++){
            if(prev>=0&&(prev^1)===dir) continue;
            const nr=zr+dirs[dir].r,nc=zc+dirs[dir].c;
            if(nr<0||nr>=n||nc<0||nc>=n) continue;
            const idx0=zr*n+zc,idx1=nr*n+nc; const next=st.slice(); [next[idx0],next[idx1]]=[next[idx1],next[idx0]];
            const t=dfs(next,nr,nc,g+1,dir); if(t==='FOUND'){ if(g===0) path.push({r:nr,c:nc}); return 'FOUND'; } if(typeof t==='number'&&t<min) min=t;
          }
          return min;
        }
        const stArr=arr.slice(),zIdx=stArr.indexOf(0),zr0=Math.floor(zIdx/n),zc0=zIdx%n;
        while(true){ const t=dfs(stArr,zr0,zc0,0,-1); if(t==='FOUND') break; if(t===Infinity) return null; bound=t; }
        return path[0];
      }

      function computeGreedyHint(){
        const flat=board.flat(),manh=a=>a.reduce((s,v,i)=>v?s+Math.abs(Math.floor(i/size)-Math.floor((v-1)/size))+Math.abs(i%size-((v-1)%size)):s,0);
        let best=null,bestH=Infinity;
        getNeighbors(emptyPos.r,emptyPos.c).forEach(p=>{
          const copy=flat.slice(),i0=emptyPos.r*size+emptyPos.c,i1=p.r*size+p.c; [copy[i0],copy[i1]]=[copy[i1],copy[i0]];
          const h=manh(copy); if(h<bestH){bestH=h;best=p;}
        });
        return best;
      }

      // Handle window resize to recalculate positions
      window.addEventListener('resize', render);

      initGame(size);
    })();
  </script>
</body>
</html>